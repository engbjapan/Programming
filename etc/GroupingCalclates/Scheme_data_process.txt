本、群処理演算の元となる思想について：
元ネタ：権利切れ日本国公開特許公報
https://www.j-platpat.inpit.go.jp/c1800/PU/JP-H10-341459/3FCE252C06C1D315233596B46333AFD3F6BFD0512135C3C6D7E42649FF165524/11/ja

  １）単純加算例
    １：要件とロジック（Python純粋コードによる模倣）
      （１）1024対象の入力信号変化回数（パルス数）に応じて対象別の現選択値をbit論理演算ロジックで高速に求める
      （２）使用するCPUのデータ幅は32ビット
      （３）パルス数を3ビット幅とした1024対象分の2次元配列（CPU32ビット幅のデータx3値bit行x32列）：
          plsin=[
            [#パルス数を3ビットで32対象分を示した行(0-31対象)
            0b0001...,#計32ビット 3bit目  MSB
            0b1010...,#計32ビット 2bit目
            0b0110...,#計32ビット 1bit目  LSB
            ],
            ...
            [#パルス数を3ビットで32対象分を示した行(991-1023対象)
            0b0001...,#計32ビット 3bit目  MSB
            0b1010...,#計32ビット 2bit目
            0b0110...,#計32ビット 1bit目  LSB
            ],
          ]
      （４）CaryUpを考えない現選択値を3ビット幅とした1024対象分の2次元配列（CPU32ビット幅のデータx3値bit行x32列）：
          selects=[
            [#現選択値を3ビットで32対象分を示した行(0-31対象)
            0b0000...,#計32ビット 3bit目  MSB
            0b0100...,#計32ビット 2bit目
            0b1011...,#計32ビット 1bit目  LSB
            ],
            ...
            [#現選択値を3ビットで32対象分を示した行(991-1023対象)
            0b0000...,#計32ビット 3bit目  MSB
            0b0100...,#計32ビット 2bit目
            0b1011...,#計32ビット 1bit目  LSB
            ],
          ]
      （５）  （４）＝（４）＋（３）ロジック：
```python
bit_len = 3
for pn, (s32, p32) in enumerate(zip(selects, plsin)):  # enumerateとzipの間の括弧を修正
    Cup = 0
    for b in range(bit_len - 1, -1, -1):  # ループの範囲を修正
        S = s32[b]
        P = p32[b]
        # 半加算Logic
        Cup, Sset = (S & P, S ^ P)
        if b < (bit_len - 1):
            # 半加算結果より全加算を行うLogic
            Cup, Sset = (Sset & Cup, Sset ^ Cup)  # 全加算ロジックを修正
        s32[b] = Sset

```

#１：定義セクションArray 2次元
[
[bit_length],#現、対象要素データ中の最大値から求めたbit幅の値,若しくは対象要素数（これをデフォルト指定に）
[rengept],#レンジ情報 （0=整数、１＝0-1:の非浮動小数、２＝浮動小数、、、？？？）

[sinvalus],#対象別符号bit列（bit_length分のbit幅で表現） 1=負、0=正

[maskvalue],'''
対象データbit列マスク（bit_length分のbit幅で表現）
 演算実施有無の分岐に用いる。
   演算適用後にANDする事で非対象データbitの演算値を無効にする事で演算分岐とするFlag要素
   bit値1=対象、bit値0=非対象
'''

[points], #小数点行位置（対象データのbit行列lengthに対する相対値）
]


#２：対象データのbit行列セクションArray ２次元
#   設定されたデータは対象要素別に１bitで示す整数値
# !!OS（若しくはNumpy等の内部）がビット演算操作可能なデータ幅で対象数を更に列分割する事！！＝＞冒頭の特許での32ビット長分割を参考
#    [32対象データ1,32対象データ2,...] #データ内容は正数この場合uint32
[
"""以下の行数と位置は変動する
加算・乗算系によりMSBが伸びる（CaryUP）
減算・除算系によりLSBが伸びる（CaryDown）
  上記のCaryUp/Downは演算前の小数点ポイント（位置ポイントで、定義セクションのpoints）を更新する
"""
[対象要素データMSB],#データ内容は正数（Pythonでは、ほぼ無限整数）
...
[対象要素データLSB],
]


１．arrayはシフトアップやufunc定義演算の高速化のためにNdarrayとすると

２．行数と位置の変動操作：
  １）単位演算適用後
  ・CaryUPが有れば[0]のLSB行を加え、points-1
  ・CaryDownが有れば[0]のMSB行を加え、points+1
  ２）リフレッシュ（一連の演算を行い終えたら（終えなくとも可））
  ・MSBから下って行の値が連続した[0]の行を削除（但し、pointsを越えない範囲で）
  ・LSBから上って行の値が連続した[0]の行を削除（但し、pointsを越えない範囲で）
  ・pointsを相応に更新

３．フロー制御について：
  １）フロー制御はループ処理に限る
    ・更に、ループ処理は、Array > map > lambda 的な操作としたいのでNumpyのndarrayに対するufunc適用メカニズムを採用する。
  ２）分岐フローは主に、演算を適用するか否かに限るようにし、演算結果へ適用対象のbitを1としたbitパターンデータでAND演算する。

